<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
	<title>Algorithm</title>
</head>
<body>
    <header>
            <nav>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="dataset.html">Dataset</a></li>
                    <li><a href="algorithm.html">Algorithm</a></li>
                    <li><a href="people.html">People</a></li>
                </ul>
            </nav>
    </header>
    <main>
            <div class="box1">
                <h1>Description of algorithm</h1>
                <p>
                    The algorithm is an interactive movie recommendation system that uses a dataset of movies stored in a JSON file. 
                    When the algorithm is executed, it first loads the JSON data from {}structured.json and converts it into a structured pandas DataFrame. 
                    This is done to more easily filter the result. Pandas DataFrames also have a lot of built in methods that we utilize when, for example, we show the movie recommendation to the user. 
                    After the JSON file is converted into a DataFrame we need to filter the DataFrame based on 3 inputs from the user; 
                    the amount of minutes the user has to watch a movie, the genre the user would like to see and the decade the user would like the movie to be from. 
                </p>
                <p>
                    After we have gotten these inputs we do some processing of them to increase the chances that the user preferences will actually match a movie in the DataFrame. 
                    Once we have gotten the inputs and processed them we use them to filter the DataFrame and then print out a random result to the user based on their preferences. 
                    If the input the user provided matches only 1 movie they will get the same movie each they input that but if the input matches with several movies they might get a new movie each time. 
                    Users also have the option to get a completely random movie recommendation if they would like to.
                </p>
                <p>
                    The algorithm is entirely self-contained and does not save or track user data. This means that each session is independent and when the application is closed, the user input is also cleared. 
                    This mitigates some of the ethical considerations one has to account for when dealing with user data, since we are not gathering any user data. There are two main drawbacks to this approach however. 
                    The first one is from a user perspective. Since we don't store any data the user won't be able to see past recommendations and if the user accidentally closes down the application they might not get the same recommendation even if they send in the same input. 
                    The second drawback is that the algorithm is static as opposed to self-reinforcing or “learning”. This means that the process of providing recommendations won't improve with more use of the algorithm. 
                    A potential enhancement in the future could be lightweight learning or local storage that remembers user preferences or favorite genres or previous movie recommendations, 
                    and these would help further personalize and adapt the recommendations while still not gathering any personal information about the users.
                </p>
                <h4>Challenges</h4>
                <p>
                    In the beginning of the project, we brainstormed what the features or steps of our algorithm should be. 
                    Once we settled on the problem the algorithm would solve (recommend a movie from the dataset based on user input) we created a text file called <a href = "https://github.com/JustcallmeErik/datalogicalthinking-HT25-group2/blob/main/drafts/applicationFlowAndPseudoCodeConsoleApp">“applicationFlowAndPseudoCodeConsoleApp”</a>. 
                    The idea with this file was not to use “true” pseudo code as we have been taught in class but rather to describe the steps/ flow of the application to have a reference point when developing the algorithm. 
                    Below are some of the challenges we encountered and you can read the txt file in the repository on github.
                </p>
                <p>
                    <ol>
                        <li><b>How to order the inputs:</b>
                            <p>When developing an algorithm that depends on user input it is important to make it clear to the user what the expected input should be at the different steps to aid the usability of the application. 
                                We decided on the order Time>Genre>Decade since we thought it would be most intuitive for the user since they most likely already know much time they have to watch a movie (although perhaps not down to the minute), 
                                then what genre they are in the mood for and finally once they have settled on a genre they can decide the decade. The reason to get the decade input last is that once the user decides on a genre they might already have a decade in mind.
                                We know that by using assumptions, we are limiting the user. However, since user testing is outside of the scope of the project we only have our own assumptions to go by. If we made a 2.0 version this is perhaps the most obvious improvement point.
                            </p>
                        </li>
                        <li><b>How to deal with time?</b>
                            <p>
                                We ask the user to enter a time to identify how much approximate time they would want to allocate to watch a movie. Then we turn this time into a range by adding +10  and - 10 minutes.
                                We did this to increase the chance that this input will yield a result and so the user did not have to guess on an exact time value. 
                                We also made an assumption here that when a user is in the mood to watch a movie they wouldn't mind the movie being 10 minutes longer or shorter.
                            </p>
                        </li>
                        <li><b>How to deal with strings to filter by genre?</b>
                            <p>
                                We have a limited number of genres. 
                                Since it's not clear to the user what the options are, we decided to print out all the genres available.
                                 We also converted the user input to lowercase to prevent it from being case sensitive. 
                                 One improvement point that we considered here but weren't able to do was to account for spelling mistakes by the user. 
                                 In its current state if the user misspell the genre the algorithm will return “Sorry! No Movie is found”.
                            </p>
                        </li>
                        <li><b>How to deal with decade?</b>
                            <p>
                                We get a year from the user and convert into a decade. We did this to increase the chance that the input results in a match. 
                                For example, if the user wanted to see a movie from 2011, we recommend movies from 2010 to 2019. Because, here we have also assumed that the user would like to 
                                watch a movie within the decade of the preferred year and are not interested in a specific year.
                            </p>
                        </li>
                        <li><b>How to make sure the user gets a recommendation?</b>
                            <p>
                                We wanted to validate user input and print out user friendly messages and continuously run the algorithm so that the user could get to the end without it ending abruptly. 
                                We solved this by implementing a loop which is calling  the main function as long as the user does not decide to end the program. 
                                For instance, when the algorithm asks the user to enter number (1,2,3), and if the user entered a different number (int) or a letter (string), we print “"Wrong input, Please select 1, 2, or 3" and ask for a new input again. 
                                We are clearly stating the options and expected input within each question of the algorithm to minimize errors that otherwise might be caused by the user. We also allow the user to choose and end the algorithm.
                            </p>
                        </li>
                    </ol>
                </p>
                <h4>The Movie Recommender Algorithm</h4>
                <pre><code class="python">
import json
import pandas as pd


with open("data/output2.json", "r", encoding="utf-8") as f:
    json_data = json.load(f) 

df = pd.json_normalize(json_data)

def main():
    # taking user input
    selection = int(input('''Please select an option:
        1. If you are looking for recomendations based on your preferences.
        2. If you would like a random movie recomendation.
        3. If to exit.
        \n
        '''))
    try:
        # test user input 
        if selection == 1:
            movie_recommender() # call the function movie_recommender()
        
        elif selection == 2: 
            random_movie() # call the random_movie() function

        elif selection == 3:
            print('''
        See You! \n''')
        
        else:
            # if the user enter int value other than 1,2,3
            print("Wrong input, Please select 1, 2, or 3")
            main() # run function again
            
    except:
        # handle error
        print("Wrong input, please try again.") 
        main()      

def movie_recommender():
    # we get and store user inputs
    minutes = int(input('''
        Exciting! How much time(minutes) do you have to watch the movie?
        The shortest movie we have is 45 minutes and the longest 321 minutes.
        \n
        ''')) 
    if minutes < 45:
        print('''
        Looks like you don't have time to watch a movie!
        \n''') 
        main()
    else:

         genre = input('''
        Which genre are you looking for?
        \n
        We have these genres to choose from: \n
        Action, Adventure, Animation, Biography, Crime, Comedy, Drama, Fantasy, \n
        Film-Noir, History, Horror, Music, Musical, Mystery, Romance, Sci-fi, Sport, Thriller, War, Western

        ''').strip().lower() # we convert the input to lowercase and remove any extra space 

         year = int(input('''
        Great! From which decade would you like the movie to be from?
        We have movies from the 1920s to the 2020s.
        \n
        '''))
       
    get_data(genre, minutes, year) # call get_data() function

def get_data(genre, minutes, year):

    matching_rows = [] # define an empty list
    for i in range(len(df)):
        g_list = df.loc[i, 'Genre'] # get the Genre column for each row
        g_list = [g.lower() for g in g_list]  # convert all the values to lowercase in Genre
        if genre in g_list:  # if the given genre is in the list
            matching_rows.append(df.loc[i]) # if matched, we add the row into the empty list

    genre_df = pd.DataFrame(matching_rows) # convert list into a dataframe


    min_time = minutes - 10 # set lower limit for a runtime
    max_time = minutes + 10 # set upper limit for a runtime

    # we filter the genre_df further by time duration and assign into a new dataframe
    time_df = genre_df.loc[(genre_df['Runtime'] >= min_time) 
                                 & (genre_df['Runtime'] <= max_time) ]

    # we want to turn the year into a year
    decade_start = year - (year%10)
    decade_end = decade_start + 9


     # we filter the time_df further by year  and assign into a new dataframe
    year_df = time_df.loc[(time_df['Released_Year'] >= decade_start)
                          & (time_df['Released_Year'] <= decade_end)]

    # if the dataframe is empty
    if year_df.empty:
        print("Sorry! No Movie is found \n")
        main()
    else:
        # get only the first row
        year_df = year_df.head(1)
        # print dataframe
        for _, row in year_df.iterrows():
            print("\n")
            print("\n")
            print(f'''I think you would enjoy: \n
            "{row['Series_Title']}" 
            {row['Released_Year']} | {time_convert(int(row['Runtime']))}\n
            IMDB Rating: {row['IMDB_Rating']} ({', '.join(row['Genre'])}) \n
            Overview:
            {row['Overview']}
            Director: {row['Director']} 
            Stars: {', '.join(row['Stars'])}. 
            \n''')
        main()

def random_movie():
    # if the user select 2 
    results = df.sample(n=1, replace=True) # here we take random two values from dataset and it will not give the same result twice
    for _, row in results.iterrows():
            print("\n")
            print(f'''I think you would enjoy: \n
            "{row['Series_Title']}" 
            {row['Released_Year']} | {time_convert(int(row['Runtime']))}\n
            IMDB Rating: {row['IMDB_Rating']} ({', '.join(row['Genre'])}) \n
            Overview:
            {row['Overview']}
            Director: {row['Director']} 
            Stars: {', '.join(row['Stars'])}. 
            \n''')
    main() # call main() function

def time_convert(time):
    hr = time//60
    m = time%60
    #print(hr, "h ", m, "min")
    return f"{hr}h {m}min"

main()
                    </code></pre>
                <h2>Limitations</h2>
                <p>
                    <ul>
                        <li>
                        <p>
                            When developing the algorithm we did not make use of concepts like information hiding discussed in chapter 7 in Computer Science Illuminated by Nell Dale and John Lewis. 
                            Instead we developed the algorithm to fit the dataset and also modified the dataset to suit the algorithm. 
                            This means that the algorithm is not as general purpose as it could have been and if the dataset were to be exchanged for a different one the algorithm would most likely break.
                        </p>  
                        </li>
                        <li>
                            <p>
                            If the user enters multiple values as the input for Genre (ex: Action, Drama), the algorithm will not work. 
                            We have designed it to take only one string value (ex: Drama).
                            </p>
                        </li>
                        <li><p>
                            When asking the user for the time input, we display the lowest and highest duration of movies anticipating that the user will not enter a higher number than 321 (+10) that will fall out of range of Runtime. 
                            If the user has “too much time” they won't find a result that matches and will get “Sorry no movie found”. 
                            A clear improvement point here is that if a user has enough time to watch 2 or more movies they should be recommended multiple movies. We do, however, validate for the lowest duration.
                        </p>
                        </li>
                        <li>
                            <p>
                            If the user wanted to get a random movie recommendation, it would never produce the same movie output twice. This could be both a good and bad feature. 
                            It is good if the user has already watched the displayed movie. It is bad if the user wants to get the same movie recommended.
                            </p>
                        </li>
                    </ul>    
            </div>
     
    <footer>
    </footer>
</body>
</html>